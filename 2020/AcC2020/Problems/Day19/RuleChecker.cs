using System;
using System.Collections.Generic;
using System.Linq;

namespace AoC.AoC2020.Problems.Day19
{
    public class RuleChecker
    {
        private readonly Dictionary<int, Rule> _rules;

        public RuleChecker(Dictionary<int, Rule> rules)
        {
            _rules = rules ?? throw new ArgumentNullException(nameof(rules));
        }

        public int CountMatchedMessages(int ruleId, List<string> messages)
        {
            int count = 0;
            foreach (var message in messages)
            {
                var result = FindRuleMatches(0,  message).ToList();
                if (result.Contains(message)) count++;  // should only be 1 or 0 string found
            }

            return count;
        }

        public void UpdateRule(Rule newRule)
        {
            _rules.Remove(newRule.RuleId);
            _rules.Add(newRule.RuleId, newRule);
        }

        // Recursive search to check if a message obeys the specified rule.
        // Technically we don't need the message parameter - we could just return all possible strings generated by the rule.
        // But this is much more efficient as we can immediately discard any rule that don't match without fully checking their child rules.
        // It also prevents an infinite loop in Part 2 where the rules can loop!
        private IEnumerable<string> FindRuleMatches(int ruleId,  string message)
        {
            var rule = _rules[ruleId];
            var allMatches = new HashSet<string>();

            if (rule.IsLetter)
            {
                yield return rule.Letter;
            }
            else
            {
                // If its not a letter - the rule will have 1 or more sub-rules.  
                // We need to check each of them individually
                foreach (var subRuleGroup in rule.SubRuleGroups)
                {
                    // Start with an empty string - this set will build up for each rule we process
                    // We work through the subRules combining the previous results with the results of finding matches for the current subRule.
                    // So we can't edit the set of inputs until after we've got all the results for the subRule.
                    var matchedPatterns = new HashSet<string>() { "" }; ;
                    var tempGroup = new HashSet<string>();  // cache the results of each iteration

                    foreach (var id in subRuleGroup)
                    {
                        foreach (var messagePattern in matchedPatterns)
                        {
                            // Combine the new matches with the messagePattern - and keep any where it matches the message. 
                            tempGroup.UnionWith(FindRuleMatches(id, message.Substring(messagePattern.Length))
                                      .Select(s => messagePattern + s)
                                      .Where(s => message.StartsWith(s)));
                        }

                        // Reset the group of patterns to check against for each iteration
                        matchedPatterns = tempGroup.ToHashSet();
                        tempGroup.Clear();
                    }

                    foreach (var s in matchedPatterns)
                    {
                        yield return s;
                    }
                }
            }
        }
    }
}